function write_tb_data(rundir,LRUSelect, maxPackets, maxGap)
    % write testbench data for simulation testing of a module
    % Inputs
    %  rundir : the directory containing the configuration files for this run
    %  lruSelect : Which LRU to generate the register setting files for.
    %  maxPackets : Maximum number of data packets to put in the testbench files (otherwise files can be very large and take a very long time to simulate)
    %  maxGap : maximum gap between packets in clock cycles, to avoid very long simulation times with no activity,
    % Outputs:
    %  (1) Text files with lines of the form 
    %       >[args_register_name][offset] 
    %       >value0
    %       >value1 etc.
    %      Notes:
    %       * "offset" is a word offset from the address referenced by "args_register_name",
    %         and value0, value1 etc are 32 bit data words in hexadecimal.
    %       * The data for this file is compiled into the matlab structure "regwrites" and written to text files at the end of this function.
    %       * A separate file is produced for each update of the registers 
    %        (e.g. for local Doppler, there are multiple different sets of values as the doppler correction is updated).
    %  (2) VHDL testbench package with a procedure that generates AXI4-lite transactions to write register values.
    %      Uses two functions from the axi4_lite_pkg (defined in libraries/base/axi4/src/vhdl/axi4_lite_pkg.vhd)
    %       - axi_lite_transaction()  - for single register writes
    %       - axi_lite_blockwrite()   - for writing to memories.
    %  (3) Text files with values used by the axi_lite_blockwrite function.
    %

    if exist("OCTAVE_VERSION", "builtin") > 0
        octave_reg = loadjson([rundir '/registerSettings.txt']);
        for ii = 1:length(octave_reg.LRU)
            registers.LRU(ii) = octave_reg.LRU{ii};
        end
        registers.global = octave_reg.global;
    else
        fid = fopen([rundir '/registerSettings.txt']);
        regjson = fread(fid,inf);
        fclose(fid);
        regjson = char(regjson');
        registers = jsondecode(regjson);
    end

    %keyboard
    
    %% Setup for the file to write data to for upload to the real hardware.
    numberOfUpdates = size(registers.LRU(LRUSelect).LDcountOffset,2);
    rCount = zeros(1,numberOfUpdates);  % Number of register writes for each file.
    %% Generate headers and introduction for the VHDL package
    pkgfid = fopen([rundir '/tb/' rundir '_tb_pkg.vhd'],'wt');
    fprintf(pkgfid,'--\n');
    fprintf(pkgfid,'-- Package generated by Perentie Matlab packetised model. \n');
    fprintf(pkgfid,['-- Procedures to configure AXI-lite peripherals according to the ' rundir ' test case.\n']);
    if exist("OCTAVE_VERSION", "builtin") > 0
        fprintf(pkgfid,['-- Creation Date ' date() ' \n']);
    else
        fprintf(pkgfid,['-- Creation Date ' datestr(datetime) ' \n']);
    end
    fprintf(pkgfid,'library IEEE, axi4_lib, LFAADecode_lib, localDoppler_lib;\n');
    fprintf(pkgfid,'use ieee.std_logic_1164.all;\n');
    fprintf(pkgfid,'use ieee.numeric_std.all;\n');
    fprintf(pkgfid,'use axi4_lib.axi4_lite_pkg.all;\n');
    fprintf(pkgfid,'use LFAADecode_LFAADecode_lib.LFAADecode_LFAADecode_reg_pkg.all;\n');
    fprintf(pkgfid,'\n');
    fprintf(pkgfid,['package ' rundir '_tb_pkg is \n']);
    fprintf(pkgfid,'    procedure setupLFAADecode(signal mm_clk : in std_logic;\n');
    fprintf(pkgfid,'                              signal axi_miso : in t_axi4_lite_miso;\n');
    fprintf(pkgfid,'                              signal axi_mosi : out t_axi4_lite_mosi);\n\n');

    for update = 1:numberOfUpdates
        fprintf(pkgfid,['    procedure setupLocalDopplerUpdate' num2str(update) '(signal mm_clk : in std_logic;\n']);
        fprintf(pkgfid,'                              signal axi_miso : in t_axi4_lite_miso;\n');
        fprintf(pkgfid,'                              signal axi_mosi : out t_axi4_lite_mosi);\n\n');
    end
    
    fprintf(pkgfid,['end ' rundir '_tb_pkg;\n\n']);
    fprintf(pkgfid,['package body ' rundir '_tb_pkg is \n']);
    
    %% Configuration of the LFAADecode module
    fprintf(pkgfid,['    procedure setupLFAADecode(signal mm_clk : in std_logic;\n']);
    fprintf(pkgfid,['                              signal axi_miso : in t_axi4_lite_miso;\n']);
    fprintf(pkgfid,['                              signal axi_mosi : out t_axi4_lite_mosi) is\n']);
    fprintf(pkgfid,['    begin \n']);
    
    % Virtual channel table
    fprintf(pkgfid,['        axi_lite_blockwrite(mm_clk, axi_miso, axi_mosi, c_statctrl_vctable_address, \"LFAADecode_VCTable.txt\");\n']);
    % create LFAADecode_VCTable.txt
    vcfid = fopen([rundir '/tb/LFAADecode_VCTable.txt'],'wt');
    for n1 = 1:1024
        fprintf(vcfid,[dec2hex(registers.LRU(LRUSelect).virtualChannel(n1),8) '\n']);
    end
    fclose(vcfid);
    % another version of LFAADecode_VCTable.txt, LFAADecode_VCTableFW.txt, which has 0x prefix and memory name included
    % (used by gemini viewer for uploading to the firmware)
    vcfid = fopen([rundir '/tb/LFAADecode_VCTableFW.txt'],'wt');
    fprintf(vcfid,'[lfaadecode.statctrl.vctable]\n');
    for n1 = 1:1024
        fprintf(vcfid,['0x' dec2hex(registers.LRU(LRUSelect).virtualChannel(n1),8) '\n']);
    end
    fclose(vcfid);    
    
    
    rCount(1) = rCount(1) + 1;
    regWrites{1}(rCount(1)).name = 'LFAADecode_statctrl_VCTable';
    regWrites{1}(rCount(1)).addr = 0;
    regWrites{1}(rCount(1)).data = registers.LRU(LRUSelect).virtualChannel;
    
    % station IDs
    fprintf(pkgfid,['        axi_lite_transaction(mm_clk, axi_miso, axi_mosi, c_statctrl_stationid1_address, true, x\"' dec2hex(registers.LRU(LRUSelect).stationID(1),8) '\");\n']);
    rCount(1) = rCount(1) + 1;
    regWrites{1}(rCount(1)).name = 'LFAADecode_statctrl_stationid1_address';
    regWrites{1}(rCount(1)).addr = 0;
    regWrites{1}(rCount(1)).data = registers.LRU(LRUSelect).stationID(1);
    fprintf(pkgfid,['        axi_lite_transaction(mm_clk, axi_miso, axi_mosi, c_statctrl_stationid2_address, true, x\"' dec2hex(registers.LRU(LRUSelect).stationID(2),8) '\");\n\n']);
    rCount(1) = rCount(1) + 1;
    regWrites{1}(rCount(1)).name = 'LFAADecode_statctrl_stationid2_address';
    regWrites{1}(rCount(1)).addr = 0;
    regWrites{1}(rCount(1)).data = registers.LRU(LRUSelect).stationID(2);
    fprintf(pkgfid,'    end procedure;\n\n');
    %% Configure the local Doppler module
    % Loop through the updates
    numberOfUpdates = size(registers.LRU(LRUSelect).LDcountOffset,2);
    for update = 1:numberOfUpdates
        fprintf(pkgfid,['    procedure setupLocalDopplerUpdate' num2str(update) '(signal mm_clk : in std_logic;\n']);
        fprintf(pkgfid,['                      signal axi_miso : in t_axi4_lite_miso;\n']);
        fprintf(pkgfid,['                      signal axi_mosi : out t_axi4_lite_mosi) is\n']);
        fprintf(pkgfid,['    begin \n']);
        
        % LD countOffsetBuf0
        if (mod(update,2) == 1)
            fprintf(pkgfid,['        axi_lite_blockwrite(mm_clk, axi_miso, axi_mosi, c_LDCountOffset_address, \"LDCountOffset' num2str(update) '.txt\");\n']);
            fprintf(pkgfid,['        axi_lite_blockwrite(mm_clk, axi_miso, axi_mosi, c_LDStartPhase_address, \"LDStartPhase' num2str(update) '.txt\");\n']);
            fprintf(pkgfid,['        axi_lite_blockwrite(mm_clk, axi_miso, axi_mosi, c_LDPhaseStep_address, \"LDPhaseStep' num2str(update) '.txt\");\n']);
        else
            fprintf(pkgfid,['        axi_lite_blockwrite(mm_clk, axi_miso, axi_mosi, c_LDCountOffset_address + 768*4, \"LDCountOffset' num2str(update) '.txt\");\n']);
            fprintf(pkgfid,['        axi_lite_blockwrite(mm_clk, axi_miso, axi_mosi, c_LDStartPhase_address + 1536*4, \"LDStartPhase' num2str(update) '.txt\");\n']);
            fprintf(pkgfid,['        axi_lite_blockwrite(mm_clk, axi_miso, axi_mosi, c_LDPhaseStep_address + 1536*4, \"LDPhaseStep' num2str(update) '.txt\");\n']);
        end
        
        fprintf(pkgfid,['    end procedure\n']);
        
        vcfid = fopen([rundir '/tb/LDCountOffset' num2str(update) '.txt'],'wt');
        for n1 = 1:768
            fprintf(vcfid,[dec2hex(registers.LRU(LRUSelect).LDcountOffset(n1,update),8) '\n']);
        end
        fclose(vcfid);
        
        % HW upload file data
        rCount(update) = rCount(update) + 1;
        regWrites{update}(rCount(update)).name = 'localDoppler_countOffset';
        if (mod(update,2) == 1)
            regWrites{update}(rCount(update)).addr = 0;
        else
            regWrites{update}(rCount(update)).addr = 768;
        end
        regWrites{update}(rCount(update)).data = registers.LRU(LRUSelect).LDcountOffset(:,update);
        
        vcfid = fopen([rundir '/tb/LDStartPhase' num2str(update) '.txt'],'wt');
        for n1 = 1:1536
            fprintf(vcfid,[dec2hex(registers.LRU(LRUSelect).LDstartPhase(n1,update),8) '\n']);
        end
        fclose(vcfid);
        
        % HW upload file data
        rCount(update) = rCount(update) + 1;
        regWrites{update}(rCount(update)).name = 'localDoppler_startPhase';
        if (mod(update,2) == 1)
            regWrites{update}(rCount(update)).addr = 0;
        else
            regWrites{update}(rCount(update)).addr = 1536;
        end
        regWrites{update}(rCount(update)).data = registers.LRU(LRUSelect).LDstartPhase(:,update);
        
        vcfid = fopen([rundir '/tb/LDPhaseStep' num2str(update) '.txt'],'wt');
        for n1 = 1:1536
            fprintf(vcfid,[dec2hex(registers.LRU(LRUSelect).LDphaseStep(n1,update),8) '\n']);
        end
        fclose(vcfid);
        
        % HW upload file data
        rCount(update) = rCount(update) + 1;
        regWrites{update}(rCount(update)).name = 'localDoppler_phaseStep';
        if (mod(update,2) == 1)
            regWrites{update}(rCount(update)).addr = 0;
        else
            regWrites{update}(rCount(update)).addr = 1536;
        end
        regWrites{update}(rCount(update)).data = registers.LRU(LRUSelect).LDphaseStep(:,update);        
        
    end
    
    %% Close off the package file
    fprintf(pkgfid,['end ' rundir '_tb_pkg;\n']); 
    fclose(pkgfid);
    
    %% Write separate files for uploading to the real hardware.
    for update = 1:numberOfUpdates  % step through, one file for each register update.
         fid = fopen([rundir '/tb/HWData' num2str(update) '.txt'],'wt');
         for writeCount = 1:rCount(update)  % step through each register that we are writing to in this update.
             fprintf(fid,['[' regWrites{update}(writeCount).name '][' num2str(regWrites{update}(writeCount).addr) ']\n']);
             for n1 = 1:length(regWrites{update}(writeCount).data)
                 %keyboard
                 fprintf(fid,[dec2hex(regWrites{update}(writeCount).data(n1),8) '\n']);
             end
         end
         fclose(fid);
    end
    
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %% Data buses as text files for supplying and checking data in the testbench
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    
    %% - 40GE LFAA data 
    %   * Includes MAC addresses
    %   * Does not include the FCS
    %
    % The 40GE interface testbench uses a text file where each line has the following fields, 
    % each represented with the given number of hex digits :
    %  
    % repeats[4] valid[1] tuserSeg0[2] tuserSeg1[2] tdataSeg0[16] tdataSeg1[16]
    % 
    % Where 
    %  * Each tuser has bit fields :
    %     bit(0) = ena
    %     bit(1) = sop
    %     bit(2) = eop
    %     bit(5:3) = mty
    %     bit(6) = err
    %  * Repeats is the number of clocks to send the same thing. Useful for packets full of zeros or for gaps between packets.
    %  * Each tdata field is 8 bytes of data.
    if exist("OCTAVE_VERSION", "builtin") == 0
        rng(1); % Ensures a repeatable set of random numbers
    end
    fname = [rundir '/LFAA.mat'];
    if exist(fullfile(pwd,rundir,'LFAA.mat'),'file')
        % fpga is an array of structures, with each structure having fields
        % .headers, .data, .dataPointers, .txTimes
        load(fname,'fpga')
    else
        error(['Cannot find ' fname '. Run create_config.m to generate it']);
    end
    totalPackets = min([maxPackets,size(fpga(LRUSelect).headers,2)]);
    pkt = zeros([8312,1],'uint8');  % 8306 bytes in the packet, plus an extra 6 to get to an 8 byte boundary.
    % tuser will be 
    % first word = 0b0000011 = ena, sop
    % last word = 0b0110101 = ena, eop, mty = 6
    % remaining words = 0b0000001 = ena only.
    tuser = zeros([1039,1]);
    tuser(1) = 3;
    tuser(2:1038) = 1;
    tuser(1039) = 53;
    
    fid = fopen([rundir '/tb/LFAA40GE_tb_data.txt'],'wt');
    previousTime = fpga(1).txTimes(1);
    
    for p1 = 1:totalPackets
        
        % Compile a set of 8 byte words for this packet
        %  - Header is 114 bytes; first 112 bytes in 14 x (8byte words)
        %  - Last 2 bytes of the header, then 6 bytes of data
        %  - 1023 x (8byte words) of data; 
        %  - Final 2 bytes of data.
        pkt(1:114) = fpga(LRUSelect).headers(:,p1);
        ptr = fpga(LRUSelect).dataPointers(p1,:);  % ptr is 2 element vector, 1st element is offset within the channel (with 1 based indexing), second is the channel, with channel 0 meaning data is all zeros.
        if (ptr(2) == 0)
            pkt(115:8306) = 0;
        else
            r1 = int32(real(fpga(LRUSelect).data(ptr(1):(ptr(1)+4095),ptr(2))));
            i1 = int32(imag(fpga(LRUSelect).data(ptr(1):(ptr(1)+4095),ptr(2))));
            for c1 = 1:4096
                if (r1(c1) < 0)
                    pkt(115 + 2*(c1-1)) = uint8(r1(c1) + 256);
                else
                    pkt(115 + 2*(c1-1)) = uint8(r1(c1));
                end
                if (i1(c1) < 0)
                    pkt(116 + 2*(c1-1)) = uint8(i1(c1) + 256);
                else
                    pkt(116 + 2*(c1-1)) = uint8(i1(c1));
                end
            end
        end
        pkt(8307:8312) = 0;
        
        % build pkt into blocks of 8byte words
        for w = 1:1039
            wfull(w,1:16) = [dec2hex(pkt((w-1)*8+8),2) dec2hex(pkt((w-1)*8+7),2) dec2hex(pkt((w-1)*8+6),2) dec2hex(pkt((w-1)*8+5),2) dec2hex(pkt((w-1)*8+4),2) dec2hex(pkt((w-1)*8+3),2) dec2hex(pkt((w-1)*8+2),2) dec2hex(pkt((w-1)*8+1),2)];
        end
        
        % Insert the gap between packets
        currentTime = fpga(1).txTimes(p1);
        % The LFAA 40GE interface operates at 312.5 MHz internally, with 16 bytes per clock.
        % currentTime and previousTime are in ns.
        % A full frame will take 1039/2 = 520 clocks = 1664 ns
        gapTime = (currentTime - previousTime) - 1664;
        if (gapTime < 12)
            gapClocks = 4;
        elseif ((gapTime/3.2) > maxGap)
            gapClocks = maxGap;
        else
            gapClocks = floor(gapTime/3.2);
        end
        fprintf(fid,[dec2hex(gapClocks,4) ' 0 00 00 0000000000000000 0000000000000000\n']);
        
        
        if (rand(1) > 0.5) 
            % Start the packet in the second segment
            % Total of 1039 x 8 byte words
            %  - So the first line has 1 segment and then we have 1038/2 = 519 lines with 2 segments each.
            
            % Packet header + 6 bytes of data(15 x 8byte words)
            fprintf(fid,['0001' ' 1 00 ' dec2hex(tuser(1),2) ' 0000000000000000 ' wfull(1,:) '\n']);
            for dline = 1:7
                fprintf(fid,['0001 1 ' dec2hex(tuser(dline*2),2) ' ' dec2hex(tuser(dline*2 + 1),2) ' ' wfull(dline*2,:) ' ' wfull(dline*2 + 1,:) '\n']);
            end
            
            % Rest of the Packet data
            if (ptr(2) == 0) % fill with zeros
                fprintf(fid,[dec2hex(511,4) ' 1 ' dec2hex(tuser(2),2) ' ' dec2hex(tuser(3),2) ' 0000000000000000 0000000000000000\n']);  % Note that tuser(2) = tuser(3) = tuser(4:1038)
                fprintf(fid,[dec2hex(1,4)   ' 1 ' dec2hex(tuser(1038),2) ' ' dec2hex(tuser(1039),2) ' 0000000000000000 0000000000000000\n']); 
            else
                for dline = 1:512
                    fprintf(fid,['0001 1 ' dec2hex(tuser(dline*2),2) ' ' dec2hex(tuser(dline*2 + 1),2) ' ' wfull(dline*2,:) ' ' wfull(dline*2 + 1,:) '\n']);
                end
            end
            
        else
            % Start the packet in the first segment, last line will have only one segment used
            for dline = 1:8
                fprintf(fid,['0001 1 ' dec2hex(tuser((dline-1)*2 + 1),2) ' ' dec2hex(tuser((dline-1)*2 + 2),2) ' ' wfull((dline-1)*2+1,:) ' ' wfull((dline-1)*2+2,:) '\n']);
            end
            if (ptr(2) == 0) % fill the data part with zeros
                fprintf(fid,[dec2hex(511,4) ' 1 ' dec2hex(tuser(2),2) ' ' dec2hex(tuser(3),2) ' 0000000000000000 0000000000000000\n']);
            else
                for dline = 9:519
                    fprintf(fid,['0001 1 ' dec2hex(tuser((dline-1)*2 + 1),2) ' ' dec2hex(tuser((dline-1)*2 + 2),2) ' ' wfull((dline-1)*2+1,:) ' ' wfull((dline-1)*2+2,:) '\n']);
                end
            end
            fprintf(fid,['0001 1 ' dec2hex(tuser(1039),2) ' ' dec2hex(0,2) ' ' wfull(1039,:) ' 0000000000000000\n']);
        end
        
        % update curTime with the size of the gap between packets,
        previousTime = currentTime;
    end
    fclose(fid);
    
    
    
    %% - Doppler output
    %   * 128 bit wide bus, 1 header word, 512 data words
    % To be completed
    
    
    %%  ... and more to come
    %   - Coarse splitter output
    %     * 64 bit wide bus, 2 header words, 1024 data words. Multiple busses depending on the model configuration,
    %       (one per LRU that this LRU sends data to; 3 in the case of PISA)
    
    
    
    %keyboard
